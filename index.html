// ===== 13수 생성 알고리즘 (최근 10회차, 상위6+하위7, 보너스/미출수 가중치) =====
function lottoSystem00001212Final(allData, lastWinning) {
    const targetRound = currentBaseRound;
    // 최근 10개 회차 (연속)
    const targetRounds = [];
    for (let i = 1; i <= 10; i++) {
        targetRounds.push(targetRound - i);
    }

    // 가중치: 최신순 1.6 ~ 0.7 (0.1 간격)
    const weights = [1.6, 1.5, 1.4, 1.3, 1.2, 1.1, 1.0, 0.9, 0.8, 0.7];

    let mainPool = [];
    let bonusPool = [];
    let mainWithRound = [];

    targetRounds.forEach((r, idx) => {
        const row = FULL_DATA.find(x => x[0] === r);
        if (row) {
            const mainNums = row.slice(1, 7);
            const bonusNum = row[7];
            mainNums.forEach(n => {
                mainPool.push(n);
                mainWithRound.push({ num: n, round: r, weight: weights[idx] });
            });
            bonusPool.push(bonusNum);
            // 보너스 번호에 가중치 +0.2 추가
            mainWithRound.push({ num: bonusNum, round: r, weight: weights[idx] + 0.2 });
        }
    });

    // 본번호 집합 (중복 제거, 13수 후보는 본번호만)
    let mainSet = new Set(mainPool);
    let mainNumbers = Array.from(mainSet);

    // 가중치 점수 계산
    let wScore = {};
    mainWithRound.forEach(item => {
        wScore[item.num] = (wScore[item.num] || 0) + item.weight;
    });

    // 미출수 가중치 추가 (+0.2)
    zeroFreqNums.forEach(num => {
        if (wScore[num] !== undefined) {
            wScore[num] += 0.2;
        }
        // 본번호에 없는 미출수는 후보가 아니므로 무시
    });

    // 본번호 후보들을 가중치 점수로 정렬 (내림차순)
    let rankedMain = mainNumbers.sort((a, b) => {
        let aScore = wScore[a] || 0;
        let bScore = wScore[b] || 0;
        if (aScore > bScore) return -1;
        if (aScore < bScore) return 1;
        return a - b;
    });

    // 상위 6개 + 하위 7개
    let top6 = rankedMain.slice(0, 6);
    let bottom7 = rankedMain.slice(-7);
    let basketSet = new Set([...top6, ...bottom7]);
    let basket = Array.from(basketSet).sort((a, b) => a - b);

    // 중간에 빠진 번호 (B bag) - 전체 후보에서 basket에 없는 것
    let middleBag = rankedMain.filter(num => !basketSet.has(num));

    // 구간별 최소 1개 보장 (basket에 적용)
    let sections = [[1,10], [11,20], [21,30], [31,40], [41,45]];
    sections.forEach(([start, end]) => {
        if (!basket.some(n => n >= start && n <= end)) {
            let candidates = mainNumbers.filter(n => n >= start && n <= end && !basket.includes(n));
            if (candidates.length) {
                candidates.sort((a, b) => (wScore[b]||0) - (wScore[a]||0) || a - b);
                let newNum = candidates[0];
                // basket에서 가장 점수 낮은 번호 제거
                let lowestScore = Infinity;
                let lowestNum = null;
                basket.forEach(num => {
                    let score = wScore[num] || 0;
                    if (score < lowestScore) {
                        lowestScore = score;
                        lowestNum = num;
                    }
                });
                if (lowestNum !== null) {
                    basket = basket.filter(n => n !== lowestNum);
                    basket.push(newNum);
                }
                basket.sort((a, b) => a - b);
            }
        }
    });

    let survivorsSet = new Set([...mainPool, ...bonusPool]);
    let survivors = Array.from(survivorsSet).sort((a,b)=>a-b);
    let bonusNumbers = Array.from(new Set(bonusPool)).sort((a, b) => a - b);

    return {
        survivors: survivors,
        basket: basket,
        middleBag: middleBag,
        bonusNumbers: bonusNumbers,
        weightedScore: wScore
    };
}
